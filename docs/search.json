[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Data graphics\nI started doing data visualization work with an engineering education research group around 2008 and haven’t stopped. The iterative process we developed to “find the story” in our data has been instrumental in shaping my approach to data graphics. You can read more about our research at https://midfield.online/.\nMusic\nMy dad was a guitar player and taught me my first chords. I’ve been songwriting and performing since my teens. A favorite musical pilgrimage is the annual Swannanoa Gathering near Asheville, NC in late July. I’ve posted some draft tracks to SoundCloud.\nWork life\nI am a graduate of California State University, Northridge (1991), and the University of Washington (1993, 1995). I taught mechanical engineering courses at Rose-Hulman Institute of Technology from 2000-2020. I retired from teaching in 2020. I also spent some years in industry, primarily in consulting engineering in Anchorage, AK, and Simi Valley, CA, with shorter stints at aerospace firms in Redmond, WA and West Palm Beach, FL."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Stories",
    "section": "",
    "text": "ggplot2\n\n\nR\n\n\n\n\nUsing the scales and space arguments of facet_grid() to manage panel heights of faceted charts when categories are not independent.\n\n\n\n\n\n\n2022-03-09\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nR\n\n\n\n\nHow to prepare different forms of Likert-style survey data for the R likert package and edit the results to create 100% stacked-bar charts.\n\n\n\n\n\n\n2022-02-13\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "License",
    "section": "",
    "text": "CC-BY 4.0 for my text and images\n\nGPL-3 for my code\n\nCC0 for data"
  },
  {
    "objectID": "posts/2022-02-13-survey-data-io/index.html",
    "href": "posts/2022-02-13-survey-data-io/index.html",
    "title": "Survey data I/O with likert",
    "section": "",
    "text": "Summary. Given Likert-style survey data in one of three common forms, I shape the data to suit the input requirements of the likert R package and use the output to create 100% stacked-bar charts. In each case, I illustrate two routine revision tasks: editing the question labels on the bars and editing the opinion levels in the legend.\nThis post is a tutorial on how to prepare different forms of Likert-style survey data for the R likert package and using its output to create 100% stacked-bar charts. I focus on preparing the data for likert() input and editing its output for the final chart. For exploring the package functionality more fully, I recommend the tutorials by Laura Mudge (2019) and Jake Chanenson (2021).\nIn a companion post I develop the R script for constructing the 100% stacked-bar chart and discuss the rationale for selecting it as a more effective design for Likert-style survey data.\nI use data.table, ggplot2, and likert R packages. An appealing feature of likert is its compatibility with data.table and ggplot2 functionality. Note that to reproduce this work, likert must be at least version 1.3.6 (currently the development version).\nThe R code for the post is listed under the “R code” pointers."
  },
  {
    "objectID": "posts/2022-02-13-survey-data-io/index.html#data",
    "href": "posts/2022-02-13-survey-data-io/index.html#data",
    "title": "Survey data I/O with likert",
    "section": "Data",
    "text": "Data\nThe practice data in my example are from an engineering education article by Ashanthi Maxworth (2021), selected because the data are compact and the survey includes a Neutral option. The table from the original article is shown below. There were 31 respondents.\n\n\n\n(Original Table 3) Percentage student responses for each question in the feedback form.\n\n\nSurvey data are most likely to be reported in one of three forms: summary percentages (as above), summary counts, or row-records. The likert() function accepts any of these forms as input. The practice data, in all three forms, are available in the blog post directory in CSV files.\n\nsummary counts: case-study-2021-count.csv\nsummary percentages: case-study-2021-percent.csv\nrow-records: case-study-2021-row-record.csv"
  },
  {
    "objectID": "posts/2022-02-13-survey-data-io/index.html#summary-counts",
    "href": "posts/2022-02-13-survey-data-io/index.html#summary-counts",
    "title": "Survey data I/O with likert",
    "section": "Summary counts",
    "text": "Summary counts\nRead the prepared data file in summary count form.\n\n\nR code\n# read prepared data\ndt <- fread(\"case-study-2021-count.csv\")\n\n\n\n\nR code\nknitr::kable(dt)\n\n\n\n\n\nq_no\nstr_disagree\ndisagree\nneutral\nagree\nstr_agree\n\n\n\n\nQ1\n2\n0\n8\n12\n9\n\n\nQ2\n2\n2\n7\n14\n6\n\n\nQ3\n1\n1\n5\n9\n15\n\n\nQ4\n0\n2\n10\n12\n7\n\n\nQ5\n2\n0\n6\n11\n12\n\n\n\n\n\n\nlikert() input\nI rename the first column Item for consistency with the likert() function.\n\n\nR code\n# rename first column\nsetnames_Item(dt)\n\n# examine the result\ndt[]\n\n\n     Item str_disagree disagree neutral agree str_agree\n   <char>        <int>    <int>   <int> <int>     <int>\n1:     Q1            2        0       8    12         9\n2:     Q2            2        2       7    14         6\n3:     Q3            1        1       5     9        15\n4:     Q4            0        2      10    12         7\n5:     Q5            2        0       6    11        12\n\n\nThe likert() function accepts input data frames having this structure. The salient characteristics are:\n\none row per question\nfirst column is named Item and contains the question labels\nremaining columns are named for the opinion levels in increasing order left to right\ncolumn values are the counts of respondents choosing that option\nthe sum of row counts is the number of respondents answering that question\n\n\n\nlikert() output\nTo operate on this data frame, we assign it to the summary argument of the likert() function. The result is a list of various statistics about the Likert-style data. Note that the results output preserves the data.table structure of the input.\n\n\nR code\n# create the likert list\nlikert_list <- likert(summary = dt)\n\n# examine its structure\nstr(likert_list)\n\n\nList of 5\n $ results :Classes 'data.table' and 'data.frame':  5 obs. of  6 variables:\n  ..$ Item        : chr [1:5] \"Q1\" \"Q2\" \"Q3\" \"Q4\" ...\n  ..$ str_disagree: num [1:5] 6.45 6.45 3.23 0 6.45\n  ..$ disagree    : num [1:5] 0 6.45 3.23 6.45 0\n  ..$ neutral     : num [1:5] 25.8 22.6 16.1 32.3 19.4\n  ..$ agree       : num [1:5] 38.7 45.2 29 38.7 35.5\n  ..$ str_agree   : num [1:5] 29 19.4 48.4 22.6 38.7\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ items   : NULL\n $ grouping: NULL\n $ nlevels : num 5\n $ levels  : chr [1:5] \"str_disagree\" \"disagree\" \"neutral\" \"agree\" ...\n - attr(*, \"class\")= chr \"likert\"\n\n\nThe components of the list are:\n\nresults\n\nData frame. Percentage of responses by question, opinion level, and group.\n\nitems\n\nData frame. Copy of original row-record input (NULL in this example).\n\ngrouping\n\nCopy of original grouping vector that subsets results (NULL in this example).\n\nnlevels\n\nInteger. Number of opinion levels used in the calculations.\n\nlevels\n\nCharacter. Ordered vector of opinion level labels.\n\n\n\n\n\nBasic chart\nTo use this list to create a chart, we assign it as the first argument of the plot() function.\n\n\nR code\n# create the basic chart (default digits = 0 throws an error)\nplot(likert_list, digits = 1)\n\n\n\n\n\n\n\n100% stacked bar chart\nThe same list can be used to create a 100% stacked-bar chart by assigning it as the first argument of likert_100_pct_bar()—a function (defined at the top of the post) that wraps likert.plot and sets the likert arguments and ggplot2 functions that produce my preferred design.\n\n\nR code\n# customize the chart\nlikert_100_pct_bar(likert_list)\n\n\n\n\n\n\n\nLegend key\nThe legend key is edited via the column names of likert_list$results. Viewing its column names,\n\n\nR code\nnames(likert_list$results)\n\n\n[1] \"Item\"         \"str_disagree\" \"disagree\"     \"neutral\"      \"agree\"       \n[6] \"str_agree\"   \n\n\nUsing a vector of opinion labels defined at the top of the post, I rename the opinion columns of the data frame.\n\n\nR code\n# recode the opinion options \nsetnames_opinion_labels(likert_list$results)\n\n# examine the result\nstr(likert_list)\n\n\nList of 5\n $ results :Classes 'data.table' and 'data.frame':  5 obs. of  6 variables:\n  ..$ Item             : chr [1:5] \"Q1\" \"Q2\" \"Q3\" \"Q4\" ...\n  ..$ Strongly Disagree: num [1:5] 6.45 6.45 3.23 0 6.45\n  ..$ Disagree         : num [1:5] 0 6.45 3.23 6.45 0\n  ..$ Neutral          : num [1:5] 25.8 22.6 16.1 32.3 19.4\n  ..$ Agree            : num [1:5] 38.7 45.2 29 38.7 35.5\n  ..$ Strongly Agree   : num [1:5] 29 19.4 48.4 22.6 38.7\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ items   : NULL\n $ grouping: NULL\n $ nlevels : num 5\n $ levels  : chr [1:5] \"str_disagree\" \"disagree\" \"neutral\" \"agree\" ...\n - attr(*, \"class\")= chr \"likert\"\n\n\nThe change can be seen in the structure above and in the revised figure.\n\n\nR code\n# create the chart\nlikert_100_pct_bar(likert_list)\n\n\n\n\n\n\n\nQuestion labels\nThe question labels are edited via the values in the Item column of likert_list$results. Viewing the first column in vector form,\n\n\nR code\nlikert_list$results[[\"Item\"]]\n\n\n[1] \"Q1\" \"Q2\" \"Q3\" \"Q4\" \"Q5\"\n\n\nUsing a vector of question labels defined at the top of the post, I substitute them for the values in the original Item column.\n\n\nR code\n# recode the question labels\nlikert_list$results[, Item := question_labels]\n\n# examine the result\nstr(likert_list)\n\n\nList of 5\n $ results :Classes 'data.table' and 'data.frame':  5 obs. of  6 variables:\n  ..$ Item             : chr [1:5] \"Beyond the content\" \"Analyze errors\" \"Provide facts\" \"Develop writing\" ...\n  ..$ Strongly Disagree: num [1:5] 6.45 6.45 3.23 0 6.45\n  ..$ Disagree         : num [1:5] 0 6.45 3.23 6.45 0\n  ..$ Neutral          : num [1:5] 25.8 22.6 16.1 32.3 19.4\n  ..$ Agree            : num [1:5] 38.7 45.2 29 38.7 35.5\n  ..$ Strongly Agree   : num [1:5] 29 19.4 48.4 22.6 38.7\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ items   : NULL\n $ grouping: NULL\n $ nlevels : num 5\n $ levels  : chr [1:5] \"str_disagree\" \"disagree\" \"neutral\" \"agree\" ...\n - attr(*, \"class\")= chr \"likert\"\n\n\nAgain, the change is seen in the structure above and in the revised figure.\n\n\nR code\n# create the chart\nlikert_100_pct_bar(likert_list)\n\n\n\n\n\nThis approach is somewhat ad-hoc, but works as long as you are careful to write the substitutions in the correct order. If I were programming these steps, I would create additional tables (as in a database) and join the substitutions by clearly assigned key variables.\n\n\nOr edit the labels first\nAlternatively one can produce the same result by editing the opinion labels and question labels of the initial data frame before submitting it to likert(). The row and column structure reflects the changes.\n\n\nR code\n# read prepared data\ndt <- fread(\"case-study-2021-count.csv\")\n\n# rename columns\nsetnames_Item(dt)\nsetnames_opinion_labels(dt)\n\n# recode the question labels\ndt[, Item := question_labels]\n\n# examine the result\ndt[]\n\n\n                   Item Strongly Disagree Disagree Neutral Agree Strongly Agree\n                 <char>             <int>    <int>   <int> <int>          <int>\n1:   Beyond the content                 2        0       8    12              9\n2:       Analyze errors                 2        2       7    14              6\n3:        Provide facts                 1        1       5     9             15\n4:      Develop writing                 0        2      10    12              7\n5: Independent learning                 2        0       6    11             12\n\n\nThe likert list that results is nearly identical to the previous version except the levels vector uses the new opinion labels.\n\n\nR code\n# create the likert list\nlikert_list <- likert(summary = dt)\n\n# examine the result\nstr(likert_list)\n\n\nList of 5\n $ results :Classes 'data.table' and 'data.frame':  5 obs. of  6 variables:\n  ..$ Item             : chr [1:5] \"Beyond the content\" \"Analyze errors\" \"Provide facts\" \"Develop writing\" ...\n  ..$ Strongly Disagree: num [1:5] 6.45 6.45 3.23 0 6.45\n  ..$ Disagree         : num [1:5] 0 6.45 3.23 6.45 0\n  ..$ Neutral          : num [1:5] 25.8 22.6 16.1 32.3 19.4\n  ..$ Agree            : num [1:5] 38.7 45.2 29 38.7 35.5\n  ..$ Strongly Agree   : num [1:5] 29 19.4 48.4 22.6 38.7\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ items   : NULL\n $ grouping: NULL\n $ nlevels : num 5\n $ levels  : chr [1:5] \"Strongly Disagree\" \"Disagree\" \"Neutral\" \"Agree\" ...\n - attr(*, \"class\")= chr \"likert\"\n\n\nR code\n# create the chart\nlikert_100_pct_bar(likert_list)"
  },
  {
    "objectID": "posts/2022-02-13-survey-data-io/index.html#summary-percentages",
    "href": "posts/2022-02-13-survey-data-io/index.html#summary-percentages",
    "title": "Survey data I/O with likert",
    "section": "Summary percentages",
    "text": "Summary percentages\nRead the prepared data file in summary percentage form. The percentages are directly from the table in the source article. Like before, I rename the first column Item for consistency with the likert() function.\n\n\nR code\n# read prepared data\ndt <- fread(\"case-study-2021-percent.csv\")\n\n# rename first column\nsetnames_Item(dt)\n\n\n\n\n\n\n\nItem\nstr_disagree\ndisagree\nneutral\nagree\nstr_agree\n\n\n\n\nQ1\n6.5\n0.0\n25.8\n38.7\n29.0\n\n\nQ2\n6.5\n6.5\n22.6\n45.2\n19.4\n\n\nQ3\n3.2\n3.2\n16.1\n29.0\n48.4\n\n\nQ4\n0.0\n6.5\n32.3\n38.7\n22.6\n\n\nQ5\n6.5\n0.0\n19.4\n35.5\n38.7\n\n\n\n\n\n\nOption 1: Convert percentages to counts\nThis option is the most direct approach, assuming we know the number of respondents to each question. In this example we do (though this is not always the case). In this case study we have 31 respondents and all respondents replied to all the questions.\n\n\nR code\n# number of respondents in this example\nN_respondents <- 31\n\n# identify the numeric columns\nsel_cols <- names(dt)[sapply(dt, is.numeric)]\n\n# convert percentages to integer counts\ndt[, c(sel_cols) := lapply(.SD, function(x) round(N_respondents * x/100, 0)), .SDcols = sel_cols]\n\n\n\n\nR code\nknitr::kable(dt)\n\n\n\n\n\nItem\nstr_disagree\ndisagree\nneutral\nagree\nstr_agree\n\n\n\n\nQ1\n2\n0\n8\n12\n9\n\n\nQ2\n2\n2\n7\n14\n6\n\n\nQ3\n1\n1\n5\n9\n15\n\n\nQ4\n0\n2\n10\n12\n7\n\n\nQ5\n2\n0\n6\n11\n12\n\n\n\n\n\nThis data structure is identical to the one we worked with in the previous section, so we know how to work with it.\n\n\nOption 2: Use percentages as-is\nThis option might be necessary if we do not know the number of respondents replying to each question. Start by reading the data file and again rename the first column Item for consistency with the likert() function.\n\n\nR code\n# read prepared data\ndt <- fread(\"case-study-2021-percent.csv\")\n\n# rename first column\nsetnames_Item(dt)\n\n\n\n\n\n\n\nItem\nstr_disagree\ndisagree\nneutral\nagree\nstr_agree\n\n\n\n\nQ1\n6.5\n0.0\n25.8\n38.7\n29.0\n\n\nQ2\n6.5\n6.5\n22.6\n45.2\n19.4\n\n\nQ3\n3.2\n3.2\n16.1\n29.0\n48.4\n\n\nQ4\n0.0\n6.5\n32.3\n38.7\n22.6\n\n\nQ5\n6.5\n0.0\n19.4\n35.5\n38.7\n\n\n\n\n\nWith one row per question, the row percentages should sum to 100%. They do, but with an error due to rounding in the reported percentages.\n\n\nR code\n# check row totals of numeric columns\nsel_cols <- names(dt)[sapply(dt, is.numeric)]\nrow_sum  <- rowSums(dt[, .SD, .SDcols = sel_cols])\n\n# examine result\ndt[, row_total := row_sum]\ndt[, rounding_error := row_sum - 100]\ndt[, .(Item, row_total, rounding_error)]\n\n\n     Item row_total rounding_error\n   <char>     <num>          <num>\n1:     Q1     100.0            0.0\n2:     Q2     100.2            0.2\n3:     Q3      99.9           -0.1\n4:     Q4     100.1            0.1\n5:     Q5     100.1            0.1\n\n\nIf we ignore the rounding error, it can introduce small but noticeable errors in the bar lengths in the chart. A simple remediation is to subtract the small errors from the neutral columns so that all rows sum to 100% exactly. The adjusted Neutrals are shown below.\n\n\nR code\n# subtract error from neutral\ndt[, adjusted_neutral := neutral - rounding_error]\n\n# examine the result\ndt[, .(Item, neutral, rounding_error, adjusted_neutral)]\n\n\n     Item neutral rounding_error adjusted_neutral\n   <char>   <num>          <num>            <num>\n1:     Q1    25.8            0.0             25.8\n2:     Q2    22.6            0.2             22.4\n3:     Q3    16.1           -0.1             16.2\n4:     Q4    32.3            0.1             32.2\n5:     Q5    19.4            0.1             19.3\n\n\n\n\nlikert() input\nReplacing neutral with the adjusted neutral and deleting the temporary information columns yields the data structure I need for the summary percentage form:\n\n\nR code\n# adjust neutral\ndt[, neutral := adjusted_neutral]\n\n# delete temporary information columns\ndt[, c(\"row_total\", \"rounding_error\", \"adjusted_neutral\") := NULL]\n\n# examine the result\ndt[]\n\n\n     Item str_disagree disagree neutral agree str_agree\n   <char>        <num>    <num>   <num> <num>     <num>\n1:     Q1          6.5      0.0    25.8  38.7      29.0\n2:     Q2          6.5      6.5    22.4  45.2      19.4\n3:     Q3          3.2      3.2    16.2  29.0      48.4\n4:     Q4          0.0      6.5    32.2  38.7      22.6\n5:     Q5          6.5      0.0    19.3  35.5      38.7\n\n\nData structure:\n\none row per question\nfirst column is named Item and contains the question labels\nremaining columns are named for the opinion levels in increasing order left to right\ncolumn values are the percentages of respondents choosing that option\nthe sum of row percentages is exactly 100%\n\nTo prepare the data frame for graphing, I use the “edit the labels first” approach described earlier.\n\n\nR code\n# recode the opinion options\nsetnames_opinion_labels(dt)\n\n# recode the question labels\ndt[, Item := question_labels]\n\n# examine the result\ndt[]\n\n\n                   Item Strongly Disagree Disagree Neutral Agree Strongly Agree\n                 <char>             <num>    <num>   <num> <num>          <num>\n1:   Beyond the content               6.5      0.0    25.8  38.7           29.0\n2:       Analyze errors               6.5      6.5    22.4  45.2           19.4\n3:        Provide facts               3.2      3.2    16.2  29.0           48.4\n4:      Develop writing               0.0      6.5    32.2  38.7           22.6\n5: Independent learning               6.5      0.0    19.3  35.5           38.7\n\n\n\n\nlikert() output\nTo operate on this data frame, we again use the summary argument of likert(). The result is a list similar to that produced when we operated on summary counts and the same familiar chart.\n\n\nR code\n# create the likert list\nlikert_list <- likert(summary = dt)\n\n# examine its structure\nstr(likert_list)\n\n\nList of 5\n $ results :Classes 'data.table' and 'data.frame':  5 obs. of  6 variables:\n  ..$ Item             : chr [1:5] \"Beyond the content\" \"Analyze errors\" \"Provide facts\" \"Develop writing\" ...\n  ..$ Strongly Disagree: num [1:5] 6.5 6.5 3.2 0 6.5\n  ..$ Disagree         : num [1:5] 0 6.5 3.2 6.5 0\n  ..$ Neutral          : num [1:5] 25.8 22.4 16.2 32.2 19.3\n  ..$ Agree            : num [1:5] 38.7 45.2 29 38.7 35.5\n  ..$ Strongly Agree   : num [1:5] 29 19.4 48.4 22.6 38.7\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ items   : NULL\n $ grouping: NULL\n $ nlevels : num 5\n $ levels  : chr [1:5] \"Strongly Disagree\" \"Disagree\" \"Neutral\" \"Agree\" ...\n - attr(*, \"class\")= chr \"likert\"\n\n\nR code\n# 100% stacked bar chart\nlikert_100_pct_bar(likert_list)"
  },
  {
    "objectID": "posts/2022-02-13-survey-data-io/index.html#row-records",
    "href": "posts/2022-02-13-survey-data-io/index.html#row-records",
    "title": "Survey data I/O with likert",
    "section": "Row records",
    "text": "Row records\nIn row-record form, everything we want to know about an individual is in one row, that is, a row-record for that individual. Thus the number of rows equals the number of respondents.\nI made up a practice data set in row-record form with 31 rows and 6 columns. These are fictitious data I designed specifically to have the same summary characteristics as the published summary data used earlier.\nRead the prepared data file in row-record form and view the data frame.\n\n\nR code\n# read observed data\ndt <- fread(\"case-study-2021-row-record.csv\")\n\n# examine the result\ndt[]\n\n\n      obs    Q1    Q2    Q3    Q4    Q5\n    <int> <int> <int> <int> <int> <int>\n 1:     1     3     4     3     4     4\n 2:     2     5     1     5     3     5\n 3:     3     5     5     4     5     4\n 4:     4     3     4     5     4     5\n 5:     5     4     4     5     2     4\n 6:     6     4     3     5     3     4\n---                                    \n26:    26     5     5     5     4     5\n27:    27     5     2     3     4     1\n28:    28     3     4     5     3     5\n29:    29     3     3     4     3     4\n30:    30     4     4     5     3     1\n31:    31     4     4     5     5     5\n\n\nThe first column is a fictitious respondent ID. The remaining columns represent responses to the survey questions. For basic charts like those shown here, all columns should be question responses, so I delete the ID. Though I don’t cover it here, additional non-question columns are allowed for grouping the results. See, for example, (Mudge 2019).\n\n\nR code\n# delete the ID column\ndt[, obs := NULL]\n\n# examine the result\ndt[]\n\n\n       Q1    Q2    Q3    Q4    Q5\n    <int> <int> <int> <int> <int>\n 1:     3     4     3     4     4\n 2:     5     1     5     3     5\n 3:     5     5     4     5     4\n 4:     3     4     5     4     5\n 5:     4     4     5     2     4\n 6:     4     3     5     3     4\n---                              \n26:     5     5     5     4     5\n27:     5     2     3     4     1\n28:     3     4     5     3     5\n29:     3     3     4     3     4\n30:     4     4     5     3     1\n31:     4     4     5     5     5\n\n\n\nlikert() input\nFor the likert() function to accept data in this form, all question response columns must be factors with identical sets of levels. Reformatting the columns and checking the structure yields,\n\n\nR code\n# reformat columns as factors\nsel_cols <- names(dt)\ndt[, c(sel_cols) := lapply(.SD, function(x) factor(x, levels = 1:5)), .SDcols = sel_cols]\n\n# examine the result\ndt[]\n\n\n        Q1     Q2     Q3     Q4     Q5\n    <fctr> <fctr> <fctr> <fctr> <fctr>\n 1:      3      4      3      4      4\n 2:      5      1      5      3      5\n 3:      5      5      4      5      4\n 4:      3      4      5      4      5\n 5:      4      4      5      2      4\n 6:      4      3      5      3      4\n---                                   \n26:      5      5      5      4      5\n27:      5      2      3      4      1\n28:      3      4      5      3      5\n29:      3      3      4      3      4\n30:      4      4      5      3      1\n31:      4      4      5      5      5\n\n\nInput data structure\n\nOne row per respondent. The number of rows equals the number of respondents.\nOne column per question. The column name is the question label. The number of columns equals the number of survey questions.\n\nEach column is a factor with an identical set of levels. The number of levels equals the number of answer options in the survey.\nColumn values are the encoded opinions of the respondent: 1 (Strongly Disagree), 2 (Disagree), 3 (Neutral), etc.\n\n\n\nlikert() output\nTo operate on a row-record data frame, we assign it to the items argument of the likert() function. The result is again a list.\nHowever, unlike the previous output lists, the data.table structure of the input has not been preserved. I use data.table syntax in subsequent operations, so I convert both results and items to data.tables.\n\n\nR code\n# create likert list \nlikert_list <- likert(items = dt)\n\n# convert output data frames to data.tables\nsetDT(likert_list$results)\nsetDT(likert_list$items)\n\n# examine the result\nstr(likert_list)\n\n\nList of 6\n $ results :Classes 'data.table' and 'data.frame':  5 obs. of  6 variables:\n  ..$ Item: chr [1:5] \"Q1\" \"Q2\" \"Q3\" \"Q4\" ...\n  ..$ 1   : num [1:5] 6.45 6.45 3.23 0 6.45\n  ..$ 2   : num [1:5] 0 6.45 3.23 6.45 0\n  ..$ 3   : num [1:5] 25.8 22.6 16.1 32.3 19.4\n  ..$ 4   : num [1:5] 38.7 45.2 29 38.7 35.5\n  ..$ 5   : num [1:5] 29 19.4 48.4 22.6 38.7\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ items   :Classes 'data.table' and 'data.frame':  31 obs. of  5 variables:\n  ..$ Q1: Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 3 5 5 3 4 4 3 1 4 5 ...\n  ..$ Q2: Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 4 1 5 4 4 3 2 5 5 4 ...\n  ..$ Q3: Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 3 5 4 5 5 5 4 4 4 5 ...\n  ..$ Q4: Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 4 3 5 4 2 3 4 3 5 5 ...\n  ..$ Q5: Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 4 5 4 5 4 4 4 3 4 3 ...\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ grouping: NULL\n $ factors : NULL\n $ nlevels : int 5\n $ levels  : chr [1:5] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"class\")= chr \"likert\"\n\n\nThe components of the list are:\n\nresults\n\nData frame. Percentage of responses by question, opinion level, and group.\n\nitems\n\nData frame. Copy of original row-record input.\n\ngrouping\n\nCopy of original grouping vector that subsets results (NULL in this example).\n\nfactors\n\nCopy of original vector matching columns to factors (NULL in this example).\n\nnlevels\n\nInteger. Number of opinion levels used in the calculations.\n\nlevels\n\nCharacter. Ordered vector of opinion level labels.\n\n\n\n\nDraft chart\nWith row-record data, the plot function requires both results and items from the output list. The chart is familiar, but the opinion labels are now the integers used to encode the survey results.\n\n\nR code\nlikert_100_pct_bar(likert_list)\n\n\n\n\n\n\n\nLegend key\nAs before, the legend key is edited via the column names of likert_list$results. Note the corresponding changes in the likert list and chart.\n\n\nR code\n# recode the opinion options\nsetnames(likert_list$results, \n         old = as.character(1:5), \n         new = opinion_labels, \n         skip_absent = TRUE)\n\n# examine the result\nstr(likert_list)\n\n\nList of 6\n $ results :Classes 'data.table' and 'data.frame':  5 obs. of  6 variables:\n  ..$ Item             : chr [1:5] \"Q1\" \"Q2\" \"Q3\" \"Q4\" ...\n  ..$ Strongly Disagree: num [1:5] 6.45 6.45 3.23 0 6.45\n  ..$ Disagree         : num [1:5] 0 6.45 3.23 6.45 0\n  ..$ Neutral          : num [1:5] 25.8 22.6 16.1 32.3 19.4\n  ..$ Agree            : num [1:5] 38.7 45.2 29 38.7 35.5\n  ..$ Strongly Agree   : num [1:5] 29 19.4 48.4 22.6 38.7\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ items   :Classes 'data.table' and 'data.frame':  31 obs. of  5 variables:\n  ..$ Q1: Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 3 5 5 3 4 4 3 1 4 5 ...\n  ..$ Q2: Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 4 1 5 4 4 3 2 5 5 4 ...\n  ..$ Q3: Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 3 5 4 5 5 5 4 4 4 5 ...\n  ..$ Q4: Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 4 3 5 4 2 3 4 3 5 5 ...\n  ..$ Q5: Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 4 5 4 5 4 4 4 3 4 3 ...\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ grouping: NULL\n $ factors : NULL\n $ nlevels : int 5\n $ levels  : chr [1:5] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"class\")= chr \"likert\"\n\n\nR code\n# create the chart\nlikert_100_pct_bar(likert_list)\n\n\n\n\n\n\n\nQuestion labels\nWith row-record data, both results and items data frames must be revised to edit the question labels. Note the corresponding changes in the likert list and chart.\n\n\nR code\n# recode Item column of $results\nlikert_list$results[, Item := question_labels]\n\n# recode column names of $items\nsetnames(likert_list$items, \n         old = c(\"Q1\", \"Q2\", \"Q3\", \"Q4\", \"Q5\"), \n         new = question_labels, \n         skip_absent = TRUE)\n\n# examine the result\nstr(likert_list)\n\n\nList of 6\n $ results :Classes 'data.table' and 'data.frame':  5 obs. of  6 variables:\n  ..$ Item             : chr [1:5] \"Beyond the content\" \"Analyze errors\" \"Provide facts\" \"Develop writing\" ...\n  ..$ Strongly Disagree: num [1:5] 6.45 6.45 3.23 0 6.45\n  ..$ Disagree         : num [1:5] 0 6.45 3.23 6.45 0\n  ..$ Neutral          : num [1:5] 25.8 22.6 16.1 32.3 19.4\n  ..$ Agree            : num [1:5] 38.7 45.2 29 38.7 35.5\n  ..$ Strongly Agree   : num [1:5] 29 19.4 48.4 22.6 38.7\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ items   :Classes 'data.table' and 'data.frame':  31 obs. of  5 variables:\n  ..$ Beyond the content  : Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 3 5 5 3 4 4 3 1 4 5 ...\n  ..$ Analyze errors      : Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 4 1 5 4 4 3 2 5 5 4 ...\n  ..$ Provide facts       : Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 3 5 4 5 5 5 4 4 4 5 ...\n  ..$ Develop writing     : Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 4 3 5 4 2 3 4 3 5 5 ...\n  ..$ Independent learning: Factor w/ 5 levels \"1\",\"2\",\"3\",\"4\",..: 4 5 4 5 4 4 4 3 4 3 ...\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ grouping: NULL\n $ factors : NULL\n $ nlevels : int 5\n $ levels  : chr [1:5] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"class\")= chr \"likert\"\n\n\nR code\n# create the chart\nlikert_100_pct_bar(likert_list)\n\n\n\n\n\n\n\nOr edit the labels first\nAs before, we have an alternative approach: one can produce the same result by editing the opinion labels and question labels of the data frame before submitting it to likert(). Question labels are substituted for the column names. Opinion levels (as text) are substituted for the encoded integers, i.e., 1 = Strongly Disagree through 5 = Strongly Agree.\nTo illustrate, I start with a fresh row-record data set.\n\n\nR code\n# read prepared data\ndt <- fread(\"case-study-2021-row-record.csv\")\n\n# delete the ID column\ndt <- subset(dt, select = -c(obs))\n\n# recode the question labels in the column names\nsetnames(dt, \n         old = c(\"Q1\", \"Q2\", \"Q3\", \"Q4\", \"Q5\"), \n         new = question_labels, \n         skip_absent = TRUE)\n\n# recode integer values with opinion options  \nsel_cols <- names(dt)\ndt[, (sel_cols) := lapply(.SD, function(x) fcase(\n  x == 1, opinion_labels[1],\n  x == 2, opinion_labels[2],\n  x == 3, opinion_labels[3],\n  x == 4, opinion_labels[4],\n  x == 5, opinion_labels[5])),\n  .SDcols = sel_cols]\n\n# convert columns to factors  \ndt <- dt[, lapply(.SD, function(x) factor(x, levels = opinion_labels)), .SDcols = sel_cols]\n\n# examine the result\ndt[]\n\n\n    Beyond the content    Analyze errors  Provide facts Develop writing\n                <fctr>            <fctr>         <fctr>          <fctr>\n 1:            Neutral             Agree        Neutral           Agree\n 2:     Strongly Agree Strongly Disagree Strongly Agree         Neutral\n 3:     Strongly Agree    Strongly Agree          Agree  Strongly Agree\n 4:            Neutral             Agree Strongly Agree           Agree\n 5:              Agree             Agree Strongly Agree        Disagree\n 6:              Agree           Neutral Strongly Agree         Neutral\n---                                                                    \n26:     Strongly Agree    Strongly Agree Strongly Agree           Agree\n27:     Strongly Agree          Disagree        Neutral           Agree\n28:            Neutral             Agree Strongly Agree         Neutral\n29:            Neutral           Neutral          Agree         Neutral\n30:              Agree             Agree Strongly Agree         Neutral\n31:              Agree             Agree Strongly Agree  Strongly Agree\n    Independent learning\n                  <fctr>\n 1:                Agree\n 2:       Strongly Agree\n 3:                Agree\n 4:       Strongly Agree\n 5:                Agree\n 6:                Agree\n---                     \n26:       Strongly Agree\n27:    Strongly Disagree\n28:       Strongly Agree\n29:                Agree\n30:    Strongly Disagree\n31:       Strongly Agree\n\n\nInput to likert() produces the familiar chart.\n\n\nR code\n# create the likert list\nlikert_list <- likert(items = dt)\n\n# examine the result\nstr(likert_list)\n\n\nList of 6\n $ results :'data.frame':   5 obs. of  6 variables:\n  ..$ Item             : chr [1:5] \"Beyond the content\" \"Analyze errors\" \"Provide facts\" \"Develop writing\" ...\n  ..$ Strongly Disagree: num [1:5] 6.45 6.45 3.23 0 6.45\n  ..$ Disagree         : num [1:5] 0 6.45 3.23 6.45 0\n  ..$ Neutral          : num [1:5] 25.8 22.6 16.1 32.3 19.4\n  ..$ Agree            : num [1:5] 38.7 45.2 29 38.7 35.5\n  ..$ Strongly Agree   : num [1:5] 29 19.4 48.4 22.6 38.7\n $ items   :'data.frame':   31 obs. of  5 variables:\n  ..$ Beyond the content  : Factor w/ 5 levels \"Strongly Disagree\",..: 3 5 5 3 4 4 3 1 4 5 ...\n  ..$ Analyze errors      : Factor w/ 5 levels \"Strongly Disagree\",..: 4 1 5 4 4 3 2 5 5 4 ...\n  ..$ Provide facts       : Factor w/ 5 levels \"Strongly Disagree\",..: 3 5 4 5 5 5 4 4 4 5 ...\n  ..$ Develop writing     : Factor w/ 5 levels \"Strongly Disagree\",..: 4 3 5 4 2 3 4 3 5 5 ...\n  ..$ Independent learning: Factor w/ 5 levels \"Strongly Disagree\",..: 4 5 4 5 4 4 4 3 4 3 ...\n $ grouping: NULL\n $ factors : NULL\n $ nlevels : int 5\n $ levels  : chr [1:5] \"Strongly Disagree\" \"Disagree\" \"Neutral\" \"Agree\" ...\n - attr(*, \"class\")= chr \"likert\"\n\n\nR code\n# create the chart\nlikert_100_pct_bar(likert_list)\n\n\n\n\n\n\n\nData table\nThe results component can also be used to construct a summary data table.\n\n\nR code\nlikert_list$results\n\n\n                  Item Strongly Disagree Disagree  Neutral    Agree\n1   Beyond the content          6.451613 0.000000 25.80645 38.70968\n2       Analyze errors          6.451613 6.451613 22.58065 45.16129\n3        Provide facts          3.225806 3.225806 16.12903 29.03226\n4      Develop writing          0.000000 6.451613 32.25806 38.70968\n5 Independent learning          6.451613 0.000000 19.35484 35.48387\n  Strongly Agree\n1       29.03226\n2       19.35484\n3       48.38710\n4       22.58065\n5       38.70968\n\n\nRounding the digits, we produce a publication-ready table. I’m assuming the abbreviated question labels are OK—if not, each could be replaced with its complete assertion. In this form, the rows of the table are in the same order as the rows of the chart—a structure that could be useful to the reader.\n\n\n\n\n\n\n\n\n\n\n\n\n\nItem\nStrongly Disagree\nDisagree\nNeutral\nAgree\nStrongly Agree\n\n\n\n\nBeyond the content\n6.5\n0.0\n25.8\n38.7\n29.0\n\n\nAnalyze errors\n6.5\n6.5\n22.6\n45.2\n19.4\n\n\nProvide facts\n3.2\n3.2\n16.1\n29.0\n48.4\n\n\nDevelop writing\n0.0\n6.5\n32.3\n38.7\n22.6\n\n\nIndependent learning\n6.5\n0.0\n19.4\n35.5\n38.7\n\n\n\n\n\nThe values in this table were computed by likert from the fictitious row-record data. The numbers agree with the source data table."
  },
  {
    "objectID": "posts/2022-02-13-survey-data-io/index.html#comments",
    "href": "posts/2022-02-13-survey-data-io/index.html#comments",
    "title": "Survey data I/O with likert",
    "section": "Comments",
    "text": "Comments\nTo comment, a reader has to have a GitHub account. Use the Sign in with GitHub button and give permission to the utterances app."
  },
  {
    "objectID": "posts/2022-02-13-survey-data-io/index.html#acknowledgments",
    "href": "posts/2022-02-13-survey-data-io/index.html#acknowledgments",
    "title": "Survey data I/O with likert",
    "section": "Acknowledgments",
    "text": "Acknowledgments\n\nR and R packages\nR (version 4.1.2, 2021–11–01)\ndata.table for manipulating data (version 1.14.2)\ndistill for creating the post (version 1.3)\nggplot2 for fine-tuning the charts (version 3.3.5)\nlikert for manipulating and plotting Likert-style data (version 1.3.6)"
  },
  {
    "objectID": "posts/2022-02-19-facets-not-small-multiples/index.html",
    "href": "posts/2022-02-19-facets-not-small-multiples/index.html",
    "title": "Facets that are not small multiples",
    "section": "",
    "text": "Summary. For data structures having two categorical variables and one quantitative variable, this post illustrates how category independence or dependence influences chart design. Graphs with independent categories (multiway data) are easily created in ggplot2 with the facet_wrap() function; data with dependent categories require facet_grid() with its scales and space arguments to treat unequal vertical scales.\nSmall multiple design is a good design choice for many data structures. To facilitate visual comparisons, every small-multiple frame (variously called panels, facets, or subplots) has identical scales.\nMultiway data—a data structure comprising two independent categorical variables and one quantitative response variable—is well-matched to small multiple design.\nHowever, if the categories happen to be dependent, the data are not multiway and the small multiple design fails. Having come across data of this type in a recent article, I thought it would be interesting to illustrate, given one quantitative variable and two categorical variables, how category independence or dependence influences chart design.\nI start with a multiway data set and point out that, as a small-multiple design, the panels share common scales. In ggplot2, small multiples are usually created using facet_wrap().\nThe second example has data with dependent categories. The panels share a common, horizontal, quantitative scale but have different category scales, yielding facets that are not small multiples. I use facet_grid() with its scales and space arguments to treat the unequal vertical scales.\nThe R code for the post is listed under the “R code” pointers."
  },
  {
    "objectID": "posts/2022-02-19-facets-not-small-multiples/index.html#multiway-example",
    "href": "posts/2022-02-19-facets-not-small-multiples/index.html#multiway-example",
    "title": "Facets that are not small multiples",
    "section": "Multiway example",
    "text": "Multiway example\nThe literal textbook example of multiway data and chart design is the livestock chart by Cleveland (1993, 303). The data set contains counts of 5 types of farm animals in 26 countries in 1967. The independent categories are country and animal type; the quantitative variable is the count.\nI obtained a reproduction of the data from (UCLA 2021) and saved it as a CSV file in the blog data directory.\n\n\nR code\n# read the livestock data\nDT <- fread(\"livestock-1967.csv\")\n\n# examine the data\nDT[]\n\n\n     livestock_type        country    count\n             <char>         <char>    <num>\n  1:         Cattle        Albania   478000\n  2:         Cattle        Austria  2536000\n  3:         Cattle        Belgium  3246000\n  4:         Cattle       Bulgaria  1796000\n  5:         Cattle Czechoslovakia  5131000\n ---                                       \n126:          Sheep    Switzerland   336000\n127:          Sheep         Turkey 70093000\n128:          Sheep United Kingdom 32888000\n129:          Sheep  Russia et al. 21000000\n130:          Sheep     Yugoslavia  7384000\n\n\nThe countries are assigned to the rows such that the median count by country increases from bottom to top. The livestock are assigned to the panels such that median count by livestock type increases in graphical order: increasing from left to right and from bottom to top. The logarithm of counts is used for the quantitative scale counts vary by more than four powers of 10.\n\n\nR code\nggplot(data = DT, mapping = aes(x = log10(count), y = reorder(country, count, median))) +\n  geom_point() + \n  facet_wrap(vars(reorder(livestock_type, count, median)), as.table = FALSE) +\n  labs(x = expression('Log'[10]~'number of livestock'), y = \"\")\n\n\n\n\n\nTypical of small multiple charts in general, all five panels have identical horizontal scales (the count) and identical vertical axes (countries). It follows that the size and aspect ratio of each panel are also identical."
  },
  {
    "objectID": "posts/2022-02-19-facets-not-small-multiples/index.html#when-categories-are-dependent",
    "href": "posts/2022-02-19-facets-not-small-multiples/index.html#when-categories-are-dependent",
    "title": "Facets that are not small multiples",
    "section": "When categories are dependent",
    "text": "When categories are dependent\nThe data set that inspired this post is from an article on a creative expression assignment used in a first-year engineering course (Chambers and Reid 2021). In response to COVID-19, the course had transitioned from a highly interactive, in-person experience to an asynchronous, online model.\n\nThe instructors designed an assignment to encourage students to creatively express how the course interruption and transition online was affecting them. The assignment encouraged complete freedom of expression and choice of media.\n\nA data table in the article reports how the student work is coded: 28 creative genres (prose, lyrics, music performance, dance, YouTube, etc.) grouped into 6 media categories (writing, performance, video, graphics, etc.). The quantitative variable is the count of encodings by genre.\nSome submissions covered multiple media and genres, for example, an original song in a video would be coded as both. Thus the total of the count column (304 encodings) exceeds the number of submissions (N = 265). The percent column is a derived variable that reports the count as a percentage of N. The sum of the percent column is therefore greater than 100%.\nThe data are available in the blog data directory.\n\n\nR code\n# import the data\nDT <- fread(\"creative-assignment-2021.csv\")\n\n# print the data table\nDT[]\n\n\n         medium                 genre count percent\n         <char>                <char> <int>   <num>\n 1:     Writing                 Prose     6     2.3\n 2:     Writing                 Essay    32    12.1\n 3:     Writing              Word art     6     2.3\n 4:     Writing    Poetry (not haiku)    32    12.1\n 5:     Writing                 Haiku     4     1.5\n 6:       Music                Lyrics     3     1.1\n 7:       Music              Playlist     3     1.1\n 8: Performance Music from instrument     6     2.3\n 9: Performance  Performance of music     6     2.3\n10: Performance                 Dance     2     0.8\n11: Performance           Spoken word     2     0.8\n12:   Sculpture      Arranged objects     6     2.3\n13:   Sculpture             Sculpture     2     0.8\n14:   Sculpture                  Lego     2     0.8\n15:       Video                TikTok     7     2.6\n16:       Video               YouTube     4     1.5\n17:       Video            Short-form     9     3.4\n18:       Video                 Music     3     1.1\n19:       Video           Spoken word     5     1.9\n20:    Graphics               Collage    13     4.9\n21:    Graphics              Painting    18     6.8\n22:    Graphics       Drawing by hand    58    21.9\n23:    Graphics   Drawing by computer    10     3.8\n24:    Graphics           Photography    15     5.7\n25:    Graphics               Cartoon    18     6.8\n26:    Graphics                 Emoji     6     2.3\n27:    Graphics                  Meme    22     8.3\n28:    Graphics            Web design     4     1.5\n         medium                 genre count percent\n\n\nThe graph I have in mind would have media type assigned to rows and media category assigned to panels. Unlike the livestock example, however, the categorical variables in these data are not independent. For example, web design is associated only with graphics, essay is associated only with writing, etc.\nIn my first attempt, I use facet_wrap() like I did with the livestock data. The visual problem is obvious…every row has a data marker in one panel only. Because the categories are not independent, the small-multiple design fails.\n\n\nR code\n# create the first chart \np <- ggplot(data = DT, mapping = aes(x = percent, y = reorder(genre, count))) +\n  geom_point() + \n  facet_wrap(vars(reorder(medium, count)) , as.table = FALSE) +\n  labs(y = \"\")\n\n# display the result\np\n\n\n\n\n\nThe scales = \"free_y\" argument of facet_wrap() replaces the common y-scale with only those row labels associated with a panel. I also use the ncol argument to stack the panels in one column with all rows labels aligned on the left. This graph has the essential layout I had in mind—a common quantitative scale but different vertical scales, yielding facets that are not small multiples.\n\n\nR code\n# edit the previous chart \np <- p +\n   facet_wrap(vars(reorder(medium, count)) , as.table = FALSE, scales = \"free_y\", ncol = 1)\n\n# display the result\np\n\n\n\n\n\nBecause facet_wrap() creates panels of equal height, the rows in this case are unequally spaced.\nI switch to facet_grid() to space the rows equally in panels of unequal height. The space = \"free_y\" argument is added to make the panel height proportional to the length of the y scale.\n\n\nR code\n# edit the previous chart \np <- p  +\n  facet_grid(rows = vars(reorder(medium, count)), \n             as.table = FALSE, \n             scales = \"free_y\",\n             space = \"free_y\")\n\n# display the result\np"
  },
  {
    "objectID": "posts/2022-02-19-facets-not-small-multiples/index.html#editing-the-chart",
    "href": "posts/2022-02-19-facets-not-small-multiples/index.html#editing-the-chart",
    "title": "Facets that are not small multiples",
    "section": "Editing the chart",
    "text": "Editing the chart\nWhile the overall layout above is what I want, I would prefer to move the panel labels from the right-hand side to the top of each panel. I could not find a way to do that, so I removed the right-hand label and wrote the media label inside the panel. I edited some other aesthetics as well.\n\n\nR code\n# create a y-coordinate for a text geom\nDT <- DT[, y_coord_media := .N/2 + 0.5, by = medium]\n\n# create secondary axis data, omit some labels to avoid overprinting\ncount_scale <- sort(unique(DT$count))\ntop_axis <- data.table(count_scale)\ntop_axis[, count_label := as.character(count_scale)]\nomit_labels <- c(\"3\", \"5\", \"7\", \"9\", \"15\")\ntop_axis[count_label %chin% omit_labels, count_label := \"\"]\n\n# ratio for secondary axis transformation\nscale_trans <- sum(DT$count) / sum(DT$percent)\n\n# graph\nggplot(data = DT, mapping = aes(x = percent, y = reorder(genre, count))) +\n  geom_point(size = 2) +\n  facet_grid(rows = vars(reorder(medium, count)), \n             as.table = FALSE, \n             scales = \"free_y\",\n             space = \"free_y\") +\n  labs(x = \"Genre encodings (%)\", y = \"Genre\") +\n  theme_light() +\n  theme(strip.text.y = element_blank(), \n        panel.grid.minor = element_blank(),\n        axis.title.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +\n  geom_text(aes(x = 24, y = y_coord_media, label = medium, hjust = 1), color = \"gray50\") +\n  scale_x_continuous(sec.axis = sec_axis(trans = function(z) (z * scale_trans), \n                                         name = \"Count of genre encodings\", \n                                         breaks = top_axis$count_scale, \n                                         labels = top_axis$count_label))\n\n\n\n\n\nFeatures of the graph\n\nfacet_grid() as shown earlier for panels of unequal height with rows equally spaced.\ngeom_text() for panel labels, vertically centered.\nsec_axis() for a secondary scale along the top of the chart showing counts of genre encodings from the data table.\ntheme_light() for gray lines on white background to focus attention on the data.\nAll text is oriented horizontally for ease of reading.\nMedia are ordered by increasing counts (total count rather than median) from bottom to top.\nWithin a panel, genres are similarly ordered."
  },
  {
    "objectID": "posts/2022-02-19-facets-not-small-multiples/index.html#final-thoughts",
    "href": "posts/2022-02-19-facets-not-small-multiples/index.html#final-thoughts",
    "title": "Facets that are not small multiples",
    "section": "Final thoughts",
    "text": "Final thoughts\nRegarding their data table, the authors write,\n\n… some media were selected by large numbers of students, such as drawings by hand or computer, and writing such as poems and essays.\n\nThe graph supports this assertion but emphasizes visually a couple of other points as well. Drawings by hand, essays, and non-haiku poetry were by far the most popular genres (adding up to nearly 50% of the submission encodings) and graphics was by far the most popular medium (about 60% of the encodings).\nMainly this chart gave me a chance to clarify something that my students would sometimes overlook—that a data structure with two categories and one quantitative variable are multiway data if and only if the categories are independent and a value of the response exists for each combination of levels of the two categories. Otherwise, we cannot expect to use a small-multiple design."
  }
]