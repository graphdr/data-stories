{
  "hash": "992034a4cc3fa85cbe76bb5633de3028",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"A subtle flaw in `pull()`\"\ndescription: |\n    Demonstrating a subtle scoping flaw in `dplyr::pull()` and potential workarounds.  \ndate: \"August 1, 2024\"\ndate-format: \"YYYY--MM--DD\"\ncategories: [R, dplyr, SE/NSE]\nimage: \"thumbnail.png\"\ncap-location: margin\nformat:\n  html:\n    code-fold: false\n    code-block-border-left: true\n    code-link: true\ndraft: true\n---\n\n\n\n\n:::{.callout-note}\n## Summary \n<em>In the current version of dplyr, if `x` is not a column name in data frame `d`, then `pull(d, x)` attempts to look up the value of `x` in the  environment instead of returning NULL. There are ways to augment `pull()` to yield the expected results, though base R alternatives `[[` and `$` may also be used reliably and predictably. </em>\n:::\n\nThe current dplyr article [programming with dplyr](https://dplyr.tidyverse.org/articles/programming.html) states that the `pull()` function, like `select()`, uses \"tidy selection\"  for working with data frame columns. Accordingly, the `select()` documentation includes `<tidy-select>` in its arguments list---but the `pull()` documentation (unexpectedly) does not.  \n\nThis may just be a minor documentation error, but it does point to a subtle flaw in `pull()` that users should be aware of---if column name `x` does not exist in data frame `d`, then `pull(d, x)` unexpectedly attempts to operate on an environment-variable `x`, if present, instead of returning a NULL or an error. \n\nIn this post, I compare the behavior of `pull()` to that of `[[` and `$` for extracting a single column `x` from a data frame when column `x` exists and when it does not, while the name `x` and a value it references also exist in the environment. \n\nTo distinguish between a name in the environment and the value(s) it references and the name of a data frame column and the value(s) it references, I borrow some terminology from the dplyr article cited above:\n\n- *env-variables* live in an environment, usually created with `<-`.\n- *data-variables* live in a data frame.\n\nFor example, in the following code chunk\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = c(\"ex\", \"ex\"), y = c(\"why\", \"why\"))\ndf$x\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\nwe create a env-variable, `df`, that contains two data-variables, `x` and `y`. We then used `$` to extract the data-variable `x` from the env-variable `df`.\n\nFor reference, the R and package versions I'm using are: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nR.version$version.string\n#> [1] \"R version 4.4.1 (2024-06-14 ucrt)\"\n\nlibrary(\"dplyr\")\npackageVersion(\"dplyr\")\n#> [1] '1.1.4'\n```\n:::\n\n\n\n\n\n\n## Extracting a single column\n\nThe data frame `df` defined above is used to reset examples as needed. We continue with two new env-variables, `d` (refers to the baseline data frame) and `x` (refers to a string value). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- df\nx <- \"y\"\n```\n:::\n\n\nFor extracting a single column as a vector from a data frame, the following are roughly equivalent. Each should extract the data-variable `x` from the env-variable `d`. \n\n        d[[\"x\"]]\n        d$x\n        pull(d, x)\n\n\n \n\n\n\n## Using `[[` or `$`\n\nThe base R operator `[[` matches a character value to the column names of a data frame and returns the matching column, if any, as a vector. No partial matching is the default behavior, that is,  `d[[\"x\"]]` is equivalent to `d[[\"x\", exact = TRUE]]`. The return is the expected data-variable `x` in vector form. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd[[\"x\"]]\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\nThe base R operator `$` is similar: `d$name` is equivalent to `d[[\"name\", exact = FALSE]]` (partial matching enabled). In this case, partial matching is not relevant; we extract the expected column. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd$x\n#> [1] \"ex\" \"ex\"\n\nidentical(d[[\"x\"]], d$x)\n#> [1] TRUE\n```\n:::\n\n\nIf name `x` does not exist in `d`,   \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- select(df, -x)\n```\n:::\n\n\nboth `[[` and `$` return NULL. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd[[\"x\"]]\n#> NULL\n\nd$x\n#> NULL\n```\n:::\n\n\nBoth `[[` and `$` produce reliable and easily predictable results. \nAs expected in the examples above, the env-variable `x`  and the value it references, `\"y\"`, are irrelevant to `[[` and `$`. This turns out not to be the case with `pull()`. \n\n\n\n## Using `pull()`\n\nReset. (Binding the name `x` to the value `\"y\"` again is unnecessary, but repeated each time I reset `d` just as a reminder.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- df\nx <- \"y\"\n```\n:::\n\n\n`dplyr::pull()` extracts a column as a vector, similar to `$`. Here, the data-variable `x` is correctly extracted from `d`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, x)\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\nIf name `x` does not exist in `d`, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- select(df, -x)\n```\n:::\n\n\nthen, like `$`, we expect `pull()` to return NULL (or error)---but it doesn't.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, x)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\n`pull()`, not finding the data-variable `x` in `d`, has unexpectedly operated on the env-variable `x` and used its value to pull the `y` data-variable from `d`, exactly as if we had written `pull(d, y)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(pull(d, x), pull(d, y))\n#> [1] TRUE\n```\n:::\n\n\n---behavior surely contrary to a user's expectations. In general, one expects such behavior only when deliberately using syntax *designed* to use env-variables to extract data-variables from data frames (the topic of the section below on [programming safely](#programming-safely)). \n \nTo borrow a conclusion from John Mount [-@Mount:2018], the unfortunate coincidence that the name `x` has a value in the environment should be irrelevant to `pull()`.\n\n\n## Using `subset()`\n\nThe base R `subset()` function is known to produce a similar flawed outcome. \n\nReset. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- df\nx <- \"y\"\n```\n:::\n\n\nThe argument `drop = TRUE` yields a vector when a single column is selected. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(d, select = x, drop = TRUE)\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\nIf name `x` does not exist in `d`, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- select(df, -x)\n```\n:::\n\n\nthen, like `pull()`, the column `y` is returned instead the expected NULL or error. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(d, select = x, drop = TRUE)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\nHowever, the `subset()` documentation *does* include the following warning: \n\n> **Warning**  \n>\n> This is a convenience function intended for use interactively. For programming it is better to use the standard subsetting functions like `[`, and in particular the non-standard evaluation of argument `subset` can have unanticipated consequences.\n\nThe `pull()` documentation does not include such a warning. \n\n\n## Using `pull()` safely\n\nTo use `pull()` safely to extract column `x`, any one of three forms will currently return the expected results, including NULL or an error when the column doesn't exist. \n\nReset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- df\nx <- \"y\"\n```\n:::\n\n\n1. Quote the data-variable name.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, \"x\")\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\n2. Use the `all_of()` selection helper.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, all_of(\"x\"))\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\n3. Use the `.data` pronoun with `$`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, .data$x)\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\nIf name `x` does not exist in `d`, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- select(df, -x)\n```\n:::\n\n\nall three forms ignore the env-variable `x` and return the expected errors. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, \"x\")\n#> Error in `pull()`:\n#> ! Can't extract columns that don't exist.\n#> ✖ Column `x` doesn't exist.\n\npull(d, .data$x)\n#> Error in `pull()`:\n#> ℹ In argument: `x`.\n#> Caused by error in `.data$x`:\n#> ! Column `x` not found in `.data`.\n\npull(d, all_of(\"x\"))\n#> Error in `pull()`:\n#> ℹ In argument: `all_of(\"x\")`.\n#> Caused by error in `all_of()`:\n#> ! Can't subset elements that don't exist.\n#> ✖ Element `x` doesn't exist.\n```\n:::\n\n\nOf course, the safer syntax may be inconvenient enough to defeat the purpose of non-standard evaluation in the first place: being able to type column names without quotation marks and looking nice in pipes. For the moment, one may as well use `[[` or `$`. \n\n\n\n## Programming safely\n\nWhen programming, it is often useful to have an env-variable that references a  character vector populated with column names you expect a function to find and operate with. In the examples below, we use the env-variable `x` in function arguments to pull the column specified by its value, in this case, `\"y\"`.\n\nReset.\n \n\n::: {.cell}\n\n```{.r .cell-code}\nd <- df\nx <- \"y\"\n```\n:::\n\n\nCreate function `f` to operate on the env-variable `var` using square brackets `[[` to extract the column specified by the *value* of `var`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(dframe, var) {\n  dframe[[var]]\n}\n```\n:::\n\n\nThe `y` column is returned as desired.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nf(d, x)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\nFunction `g` using `pull()` and the `.data` pronoun yields a similar result. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- function(dframe, var) {\n  dframe %>% \n    pull(.data[[var]])\n}\n\ng(d, x)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\nFunction `h` using `pull()` and the `all_of()` selection helper also yields the desired result. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nh <- function(dframe, var) {\n  dframe %>% \n    pull(all_of(var))\n}\n\nh(d, x)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\nAs does function `q` using the rlang injection operator `!!`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nq <- function(dframe, var) {\n  dframe %>% \n    pull(!!var)\n}\n\nq(d, x)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\nAnd lastly, if name `x` does not exist in `d`, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- select(df, -y)\n```\n:::\n\n\nall four functions return a NULL or an error. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nf(d, x)\n#> NULL\n\ng(d, x)\n#> Error in `pull()`:\n#> ℹ In argument: `y`.\n#> Caused by error in `.data[[\"y\"]]`:\n#> ! Column `y` not found in `.data`.\n\nh(d, x)\n#> Error in `pull()`:\n#> ℹ In argument: `all_of(var)`.\n#> Caused by error in `all_of()`:\n#> ! Can't subset elements that don't exist.\n#> ✖ Element `y` doesn't exist.\n\nq(d, x)\n#> Error in `pull()`:\n#> ! Can't extract columns that don't exist.\n#> ✖ Column `y` doesn't exist.\n```\n:::\n\n\n\n\n\n\n## Conclusion\n\nIt appears to be an oversight that `pull()` attempts to operate on an  env-variable if the intended data-variable doesn't exist. Workarounds exist though base R alternatives `[[` and `$` may also be used reliably and predictably.  \n\n \n\n## References\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}