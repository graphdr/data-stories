{
  "hash": "e27486fd786610af708c5fca7a9500fd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"A subtle flaw in `pull()`\"\ndescription: |\n    Demonstrating a subtle scoping flaw in `dplyr::pull()` and a suggested workaround.  \ndate: \"July 27, 2024\"\ndate-format: \"YYYY--MM--DD\"\ncategories: [R, dplyr, SE/NSE]\nimage: \"thumbnail.png\"\ncap-location: margin\ndraft: true\nformat:\n  html:\n    code-fold: false\n    code-block-border-left: true\n    code-link: true\n---\n\n\n\n\n:::{.callout-note}\n## Summary \n<em>In the current version of dplyr (v1.1.4), if `x` is not a column name in data frame `d`, then `pull(d, x)` attempts to look up the value of `x` in the  environment instead of returning NULL. To produce the expected results, one may use `pull(d, \"x\")` or `pull(d, .data$x)`.</em>\n:::\n\n# Background\n\nI was recently re-reading a 6-year-old blog post [@Mount:2018] concerning a former scoping flaw in `dplyr::select()`. I ran the examples and found that the flaw in `select()` has since been corrected. \n\nA similar subtle flaw is still with us however in `dplyr::pull()`, that is, if data frame `d` has no column name `x`, then `pull(d, x)` attempts to look up the name `x` \"outside\" of `d` and, if it exists, operate on its value.  \n\nIn this post, I compare the current behavior of `pull()` to that of `[[` and `$` and demonstrate how to use `pull()` safely. For reference, the R and package versions I'm using are: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nR.version$version.string\n#> [1] \"R version 4.4.1 (2024-06-14 ucrt)\"\n\nlibrary(\"dplyr\")\npackageVersion(\"dplyr\")\n#> [1] '1.1.4'\n```\n:::\n\n\nAs an example data frame, I use a subset of the `dplyr::starwars` dataset \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaseline <- starwars %>% \n  na.omit() %>%\n  select(name, height, mass, sex) %>%\n  glimpse()\n#> Rows: 29\n#> Columns: 4\n#> $ name   <chr> \"Luke Skywalker\", \"Darth Vader\", \"Leia Organa\", \"Owen Lars\", \"B…\n#> $ height <int> 172, 202, 150, 178, 165, 183, 182, 188, 228, 180, 170, 170, 183…\n#> $ mass   <dbl> 77.0, 136.0, 49.0, 120.0, 75.0, 84.0, 77.0, 84.0, 112.0, 80.0, …\n#> $ sex    <chr> \"male\", \"male\", \"female\", \"male\", \"female\", \"male\", \"male\", \"ma…\n```\n:::\n\n\n\n## Names and values\n\nBecause this post has to do with \"names and values\", I think it prudent to clarify the distinction with an extended quote:\n\n> Consider this code: \n>\n>        x <- c(1, 2, 3)\n>\n> It's easy to read it as: “create an object named 'x', containing the values 1, 2, and 3”. Unfortunately, that's a simplification that will lead to inaccurate predictions about what R is actually doing behind the scenes. It's more accurate to say that this code is doing two things:\n>\n> - It's creating an *object*, a vector of values, `c(1, 2, 3)`.\n> - And it's binding that object to a *name*, `x`.\n>\n> In other words, the object, or value, doesn't have a name; it's actually the name that has a value. \n>\n> [@Wickham:2019], section 2.2, \"Binding basics\"\n\nThat last phrase---it's actually the name that has a value---can also be thought of as: the name \"points to\" or \"binds\" a value; or, the name is a *reference* to a value. \n\n\n\n\n\n\n## Subsetting one column with `[[` and `$`\n\nThe name `d` refers to the baseline data frame that starts each example. Suppose at some point in our script we have made the assignment using the (poorly-chosen) name `mass` to refer to the character value `\"sex\"`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- baseline\nmass <- \"sex\"\n```\n:::\n\n\nNow suppose we want to extract the mass column as a vector. Using `[[`, the name `\"mass\"` is looked up in `d` and the object to which it refers (a vector of mass values) is returned.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd[[\"mass\"]]\n#>  [1]  77.0 136.0  49.0 120.0  75.0  84.0  77.0  84.0 112.0  80.0  77.0  75.0\n#> [13]  78.2 113.0  79.0  79.0  83.0  20.0  45.0  66.0  80.0  55.0  84.0  82.0\n#> [25]  80.0  56.2  50.0  80.0  79.0\n```\n:::\n\n\nAlternatively, we can use `$` to extract a column as a vector: `d$mass` is roughly equivalent to `d[[\"mass\"]]`.  Here too the name `mass` is looked up in `d`, and the same vector of values is returned.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd$mass\n#>  [1]  77.0 136.0  49.0 120.0  75.0  84.0  77.0  84.0 112.0  80.0  77.0  75.0\n#> [13]  78.2 113.0  79.0  79.0  83.0  20.0  45.0  66.0  80.0  55.0  84.0  82.0\n#> [25]  80.0  56.2  50.0  80.0  79.0\n\nidentical(d[[\"mass\"]], d$mass)\n#> [1] TRUE\n```\n:::\n\n\nIf `d` has no column name `mass`,  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- baseline %>% \n  select(-mass)\n```\n:::\n\n\nboth `[[` and `$` return NULL. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd[[\"mass\"]]\n#> NULL\n\nd$mass\n#> NULL\n```\n:::\n\n\nAt no time was the name `mass` in the global environment and the value to which it refers relevant to `[[` or `$`. \n\nWe can, however, deliberately use a name in the global environment to extract a single column using `[[`, for example, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd[[mass]]\n#>  [1] \"male\"   \"male\"   \"female\" \"male\"   \"female\" \"male\"   \"male\"   \"male\"  \n#>  [9] \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"  \n#> [17] \"male\"   \"male\"   \"female\" \"male\"   \"male\"   \"female\" \"male\"   \"male\"  \n#> [25] \"male\"   \"female\" \"female\" \"male\"   \"male\"\n```\n:::\n\n\ntreats `mass` as a name referring to the value `\"sex\"`, which is looked up in `d` and the relevant vector is returned. Using the name, as above, or its value, as below, are equivalent. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd[[\"sex\"]]\n#>  [1] \"male\"   \"male\"   \"female\" \"male\"   \"female\" \"male\"   \"male\"   \"male\"  \n#>  [9] \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"  \n#> [17] \"male\"   \"male\"   \"female\" \"male\"   \"male\"   \"female\" \"male\"   \"male\"  \n#> [25] \"male\"   \"female\" \"female\" \"male\"   \"male\"\n\nidentical(d[[mass]], d[[\"sex\"]])\n#> [1] TRUE\n```\n:::\n\n\nIf `d` has no column name `sex`,  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- baseline %>% \n  select(-sex)\n```\n:::\n\n\nthe return is again NULL. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd[[mass]]\n#> NULL\n\nd[[\"sex\"]]\n#> NULL\n```\n:::\n\n\nBoth `[[` and `$` produce reliable and easily predictable results.\n\n\n\n\n## Subsetting one column with `pull()` \n\nReset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- baseline\n```\n:::\n\n\n`dplyr::pull()` extracts a column as a vector, similar to `$`. Here, the literal column name `mass` is looked up in `d`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, mass)\n#>  [1]  77.0 136.0  49.0 120.0  75.0  84.0  77.0  84.0 112.0  80.0  77.0  75.0\n#> [13]  78.2 113.0  79.0  79.0  83.0  20.0  45.0  66.0  80.0  55.0  84.0  82.0\n#> [25]  80.0  56.2  50.0  80.0  79.0\n```\n:::\n\n\nIf the column is missing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- baseline %>% \n  select(-mass)\n```\n:::\n\n\nwe expect `pull(d, mass)` to return a NULL, as we saw with `$`---but it does not. Unexpectedly, the name's *value* has been used, returning the `sex` column.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, mass)\n#>  [1] \"male\"   \"male\"   \"female\" \"male\"   \"female\" \"male\"   \"male\"   \"male\"  \n#>  [9] \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"  \n#> [17] \"male\"   \"male\"   \"female\" \"male\"   \"male\"   \"female\" \"male\"   \"male\"  \n#> [25] \"male\"   \"female\" \"female\" \"male\"   \"male\"\n```\n:::\n\n\nTo paraphrase John Mount, the above code expresses that we are asking for a column named \"mass\", and there is no such column in the data. The unfortunate coincidence that \"mass\" has a value in the environment should be irrelevant to `pull()`.\n\n\n\n\n\n\n## To reliably `pull()` literal variable names\n\nTo use `pull()` safely to extract the column `\"y\"`, use one of the argument forms `pull(\"y\")` or `pull(.data$y)`, both of which produce the expected results. \n\nReset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- baseline\n```\n:::\n\n\nBoth forms pull the *column* `\"mass\"`.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, \"mass\")\n#>  [1]  77.0 136.0  49.0 120.0  75.0  84.0  77.0  84.0 112.0  80.0  77.0  75.0\n#> [13]  78.2 113.0  79.0  79.0  83.0  20.0  45.0  66.0  80.0  55.0  84.0  82.0\n#> [25]  80.0  56.2  50.0  80.0  79.0\n\nidentical(pull(d, \"mass\"), pull(d, .data$mass))\n#> [1] TRUE\n```\n:::\n\n\nIf `d` has no column name `mass`,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- baseline %>% \n  select(-mass)\n```\n:::\n\n\nboth forms ignore the name `mass` in the global environment and the value it references, returning the expected errors. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, \"mass\")\n#> Error in `pull()`:\n#> ! Can't extract columns that don't exist.\n#> ✖ Column `mass` doesn't exist.\n\npull(d, .data$mass)\n#> Error in `pull()`:\n#> ℹ In argument: `mass`.\n#> Caused by error in `.data$mass`:\n#> ! Column `mass` not found in `.data`.\n```\n:::\n\n\n\n\n\n\n\n## To reliably `pull()` value-oriented variables\n\nAnd finally, if we *want* `pull()` to extract a value-oriented variable, we can use the `!!` notation from rlang. \n\nReset. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- baseline\n```\n:::\n\n\nUsing the value of the `mass` variable, we pull the `sex` column. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, !!mass) \n#>  [1] \"male\"   \"male\"   \"female\" \"male\"   \"female\" \"male\"   \"male\"   \"male\"  \n#>  [9] \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"  \n#> [17] \"male\"   \"male\"   \"female\" \"male\"   \"male\"   \"female\" \"male\"   \"male\"  \n#> [25] \"male\"   \"female\" \"female\" \"male\"   \"male\"\n```\n:::\n\n\nIf the column \"mass\" is absent, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- baseline %>% \n  select(-mass)\n```\n:::\n\n\nas expected, we get the same result. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, !!mass)\n#>  [1] \"male\"   \"male\"   \"female\" \"male\"   \"female\" \"male\"   \"male\"   \"male\"  \n#>  [9] \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"   \"male\"  \n#> [17] \"male\"   \"male\"   \"female\" \"male\"   \"male\"   \"female\" \"male\"   \"male\"  \n#> [25] \"male\"   \"female\" \"female\" \"male\"   \"male\"\n```\n:::\n\n\nAnd if the sex column is absent, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- baseline %>% \n  select(-sex)\n```\n:::\n\n\nWe get the expected error. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, !!mass)\n#> Error in `pull()`:\n#> ! Can't extract columns that don't exist.\n#> ✖ Column `sex` doesn't exist.\n```\n:::\n\n\n\n\n\n***Conclusion***\n\nIn interactive mode, where you can observe the variables present in a data frame, using `pull(y)` should present no problems---you can always check that column `\"y\"` is present before pulling. \n\nIf programming over dplyr, I suggest using `pull()` in one of its safe modes---`pull(\"y\")` or `pull(.data$y)`---or one of the base R methods, until such time as the flaw is remedied.  \n\n## References\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}