{
  "hash": "eac4e41f24ab4f710c770aab2b83d3f5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"A subtle flaw in `pull()`\"\ndescription: |\n    Demonstrating a subtle scoping flaw in `dplyr::pull()` and providing a menu of reliable workarounds.  \ndate: \"August 1, 2024\"\ndate-format: \"YYYY--MM--DD\"\ncategories: [R, dplyr, SE/NSE]\nimage: \"thumbnail.png\"\ncap-location: margin\nformat:\n  html:\n    code-fold: false\n    code-block-border-left: true\n    code-link: true\ndraft: false\n---\n\n\n\n\n:::{.callout-note}\n## Summary \n<em>In the current version of dplyr, if `x` is not a column name in data frame `d`, then `pull(d, x)` attempts to look up the value of `x` in the  environment instead of returning NULL or an error. There are ways to augment `pull()` to yield the expected results, though base R alternatives `[[` and `$` may also be used reliably and predictably. </em>\n:::\n\nA current dplyr article, [\"Programming with dplyr\"](https://dplyr.tidyverse.org/articles/programming.html), states that the `pull()` function, like `select()`, uses \"tidy selection\"  for working with data frame columns [@R-dplyr]. Accordingly, the `select()` documentation includes `<tidy-select>` in its arguments list---but the `pull()` documentation (unexpectedly) does not.  \n\n::: {.column-margin}\n<small>The thumbnail image *Pull* by Jeremy Brooks (2014) is licensed under [CC BY-NC 2.0](https://creativecommons.org/licenses/by-nc/2.0/).</small>\n:::\n\nThis may be simply a minor documentation error, but close examination reveals a subtle flaw in `pull()` that users should be aware of---if column name `x` does not exist in data frame `d`, then `pull(d, x)` unexpectedly attempts to operate on the name `x` in the environment, if present, instead of returning a NULL or an error. \n\nIn this post, I compare the behavior of `pull()` to that of `[[`, `$`, and `subset()` for extracting a single column `x` from a data frame when column `x` exists and when it does not, while the environment contains another name `x` and the value it references. \n\nTo distinguish between a name in the environment and the value(s) it references and the name of a data frame column and the value(s) it references, I borrow some terminology from the dplyr article cited above:\n\n- *env-variables* live in an environment, usually created with `<-`.\n- *data-variables* live in a data frame.\n\nFor example, in the following code chunk, I create a env-variable, `df`, that contains two data-variables, `x` and `y`. I  then use `$` to extract the data-variable `x` from the env-variable `df`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = c(\"ex\", \"ex\"), y = c(\"why\", \"why\"))\ndf\n#>    x   y\n#> 1 ex why\n#> 2 ex why\n\ndf$x\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\n\n\nFor reference, the R and package versions I'm using are as follows. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nR.version$version.string\n#> [1] \"R version 4.4.1 (2024-06-14 ucrt)\"\n\nlibrary(\"dplyr\")\npackageVersion(\"dplyr\")\n#> [1] '1.1.4'\npackageVersion(\"tidyselect\") # for all_of()\n#> [1] '1.2.1'\npackageVersion(\"magrittr\") # for %>%\n#> [1] '2.0.3'\npackageVersion(\"rlang\") # for !!\n#> [1] '1.1.4'\n```\n:::\n\n\n\n\n\n\n## Extracting a single column\n\nI start each example with two assignments: the name `d` referencing the data frame created above; and the name `x`, referencing a string value. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- df\nx <- \"y\"\n```\n:::\n\n\nFor extracting a single column as a vector from a data frame, the following are roughly equivalent. Each should extract the data-variable `x` from the env-variable `d`. \n\n        d[[\"x\"]]\n        d$x\n        pull(d, x)\n\n\n \n\n\n\n## Using `[[` or `$`\n\nThe base R operator `[[` matches a character value to the column names of a data frame and returns the matching column, if any, as a vector. No partial matching is the default behavior, that is,  `d[[\"x\"]]` is equivalent to `d[[\"x\", exact = TRUE]]`. The return is the expected data-variable `x` in vector form. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd[[\"x\"]]\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\nThe base R operator `$` is similar: `d$name` is equivalent to `d[[\"name\", exact = FALSE]]` (partial matching enabled). In this case, partial matching is not relevant; we extract the expected column. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd$x\n#> [1] \"ex\" \"ex\"\n\nidentical(d[[\"x\"]], d$x)\n#> [1] TRUE\n```\n:::\n\n\nIf name `x` does not exist in `d`,   \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- select(df, -x)\n```\n:::\n\n\nboth `[[` and `$` return NULL. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd[[\"x\"]]\n#> NULL\n\nd$x\n#> NULL\n```\n:::\n\n\nBoth `[[` and `$` produce reliable and easily predictable results. \nAs expected in the examples above, the env-variable `x`  and the value it references, `\"y\"`, are irrelevant to `[[` and `$`. This turns out (sometimes)  not to be the case with `pull()`. \n\n\n\n## Using `pull()`\n\nReset. (Binding the name `x` to the value `\"y\"` again is unnecessary, but I repeat the assignment with each reset just to remind us that the environment contains this name and value.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- df\nx <- \"y\"\n```\n:::\n\n\n`dplyr::pull()` extracts a column as a vector, similar to `$`. Here, the data-variable `x` is correctly extracted from `d`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, x)\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\nIf name `x` does not exist in `d`, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- select(df, -x)\n```\n:::\n\n\nthen, like `$`, we expect `pull()` to return NULL (or error)---but it doesn't.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, x)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\n`pull()`, not finding the data-variable `x` in `d`, has unexpectedly operated on the env-variable `x` and used its value to pull the `y` data-variable from `d`, exactly as if we had written `pull(d, y)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(pull(d, x), pull(d, y))\n#> [1] TRUE\n```\n:::\n\n\n---behavior surely contrary to a user's expectations. In general, one expects such behavior only when deliberately using syntax *designed* to use env-variables to extract data-variables from data frames (the topic of the section below on [programming safely](#programming-safely)). \n \nTo borrow a conclusion from John Mount [-@Mount:2018], the unfortunate coincidence that the name `x` has a value in the environment should be irrelevant to `pull()`. \n\n## Some background\n\nI was re-reading John Mount's opinion/tutorial piece (cited above) that demonstrated that `dplyr::select()` at the time had the same sort of flaw as the one I discuss in this post. Running Mount's examples today show that the flaw in `select()` has since been corrected. \n\nI had been working with `pull()` in another context and John's article prompted me to compare standard evaluation (SE) and non-standard evaluation (NSE) approaches to the task for which `pull()` is designed, inspiring me to write this post.  \n\nMount also showed that base R `subset()` is known to have a similar mal-feature. To illustrate, I set up `subset()` to extract one column as a vector. \n\nReset. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- df\nx <- \"y\"\n```\n:::\n\n\nThe argument `drop = TRUE` yields a vector when a single column is selected. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(d, select = x, drop = TRUE)\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\nIf name `x` does not exist in `d`, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- select(df, -x)\n```\n:::\n\n\nthen, like `pull()`, the column `y` is returned instead the expected NULL or error. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(d, select = x, drop = TRUE)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\nHowever, the `subset()` documentation *does* include the following warning about the potential for \"unanticipated consequences\" of `subset`'s non-standard evaluation (NSE) interface:  \n\n> **Warning**  \n>\n> This is a convenience function intended for use interactively. For programming it is better to use the standard subsetting functions like `[`, and in particular the non-standard evaluation of argument `subset` can have unanticipated consequences.\n\nThe `pull()` documentation does not include such a warning. \n\n\n## Using `pull()` safely\n\nTo use `pull()` safely to extract column `x`, we have three forms (at least) that currently return the expected results, including NULL or an error when the column doesn't exist. \n\nReset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- df\nx <- \"y\"\n```\n:::\n\n\n1. Quote the data-variable name.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, \"x\")\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\n2. Use the `all_of()` selection helper with the column name in quotes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, all_of(\"x\"))\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\n3. Use the `.data` pronoun with `$`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, .data$x)\n#> [1] \"ex\" \"ex\"\n```\n:::\n\n\nIf name `x` does not exist in `d`, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- select(df, -x)\n```\n:::\n\n\nall three forms ignore the env-variable `x` and return the expected errors. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(d, \"x\")\n#> Error in `pull()`:\n#> ! Can't extract columns that don't exist.\n#> ✖ Column `x` doesn't exist.\n\npull(d, all_of(\"x\"))\n#> Error in `pull()`:\n#> ℹ In argument: `all_of(\"x\")`.\n#> Caused by error in `all_of()`:\n#> ! Can't subset elements that don't exist.\n#> ✖ Element `x` doesn't exist.\n\npull(d, .data$x)\n#> Error in `pull()`:\n#> ℹ In argument: `x`.\n#> Caused by error in `.data$x`:\n#> ! Column `x` not found in `.data`.\n```\n:::\n\n\nThe safer syntax may be inconvenient enough to defeat the purpose of non-standard evaluation in the first place: being able to type column names without quotation marks and looking nice in pipes. For the moment, the alternatives `[[` or `$` may be more attractive.  \n\nOf course, like `subset()`, one can treat `pull()` as a convenience function best used interactively where the existence of the desired column can be confirmed before pulling. \n       \n\n\n\n## Programming safely\n\nWhen programming, it is often useful to have an env-variable that references a  character vector populated with column names you expect a function to find and operate with. In the examples below, we use the env-variable `x` in function arguments to pull the column specified by its value, in this case, `\"y\"`.\n\nReset.\n \n\n::: {.cell}\n\n```{.r .cell-code}\nd <- df\nx <- \"y\"\n```\n:::\n\n\nCreate function `f` to operate on the env-variable `var` using square brackets `[[` to extract the column specified by the *value* of `var`. The `y` column is returned as desired.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(dframe, var) {\n  dframe[[var]]\n}\n\nf(d, x)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\nFunction `g` using `pull()` and the `all_of()` selection helper yields a similar result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- function(dframe, var) {\n  dframe %>% \n    pull(all_of(var))\n}\n\ng(d, x)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\nFunction `h` using `pull()` and the `.data` pronoun also yields the desired result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh <- function(dframe, var) {\n  dframe %>% \n    pull(.data[[var]])\n}\n\nh(d, x)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\nAs does function `q` using the rlang injection operator `!!`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nq <- function(dframe, var) {\n  dframe %>% \n    pull(!!var)\n}\n\nq(d, x)\n#> [1] \"why\" \"why\"\n```\n:::\n\n\nAnd lastly, if name `x` does not exist in `d`, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- select(df, -y)\n```\n:::\n\n\nall four functions return a NULL or an error. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nf(d, x)\n#> NULL\n\ng(d, x)\n#> Error in `pull()`:\n#> ℹ In argument: `all_of(var)`.\n#> Caused by error in `all_of()`:\n#> ! Can't subset elements that don't exist.\n#> ✖ Element `y` doesn't exist.\n\nh(d, x)\n#> Error in `pull()`:\n#> ℹ In argument: `y`.\n#> Caused by error in `.data[[\"y\"]]`:\n#> ! Column `y` not found in `.data`.\n\nq(d, x)\n#> Error in `pull()`:\n#> ! Can't extract columns that don't exist.\n#> ✖ Column `y` doesn't exist.\n```\n:::\n\n\n\n\n\n\n## Conclusion\n\nIt appears to be an oversight that `pull()` attempts to operate on an  env-variable if the intended data-variable doesn't exist. Workarounds exist though base R alternatives `[[` and `$` may also be used reliably and predictably.  \n\n \n\n## References\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}